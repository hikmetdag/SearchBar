{"ast":null,"code":"/**\n * @module methodWrapperScoped\n *\n */\nimport matchKeys from '../lib/match_keys';\nimport parseKeys from '../lib/parse_keys';\n\n/**\n * methodWrapperScoped\n *\n * @access public\n * @param {object} args All args necessary for decorating the method\n * @param {object} args.target The decorated method's class object\n * @param {object} args.descriptor The method's descriptor object\n * @param {array} args.keys The key codes bound to the decorated method\n * @return {object} The method's descriptor object\n */\nfunction methodWrapperScoped(_ref) {\n  var target = _ref.target,\n    descriptor = _ref.descriptor,\n    keys = _ref.keys;\n  var componentWillReceiveProps = target.componentWillReceiveProps;\n  var fn = descriptor.value;\n  if (!keys) {\n    console.warn(fn + ': keydownScoped requires one or more keys');\n  } else {\n    /**\n     * _shouldTrigger\n     *\n     * @access private\n     * @param {object} thisProps Exsting props from the wrapped component\n     * @param {object} thisProps.keydown The namespaced state from the higher-order\n     * component (class_decorator)\n     * @param {object} nextProps The incoming props from the wrapped component\n     * @param {object} nextProps.keydown The namescaped state from the higher-order\n     * component (class_decorator)\n     * @param {array} keys The keys bound to the decorated method\n     * @return {boolean} Whether all tests have passed\n     */\n    var _shouldTrigger = function _shouldTrigger(keydownThis, keydownNext) {\n      if (!(keydownNext && keydownNext.event && !keydownThis.event)) return false;\n      return keySets.some(function (keySet) {\n        return matchKeys({\n          keySet: keySet,\n          event: keydownNext.event\n        });\n      });\n    };\n\n    // wrap the component's lifecycle method to intercept key codes coming down\n    // from the wrapped/scoped component up the view hierarchy. if new keydown\n    // event has arrived and the key codes match what was specified in the\n    // decorator, call the wrapped method.\n\n    var keySets = parseKeys(keys);\n    target.componentWillReceiveProps = function (nextProps) {\n      var keydownNext = nextProps.keydown;\n      var keydownThis = this.props.keydown;\n      if (_shouldTrigger(keydownThis, keydownNext)) {\n        return fn.call(this, keydownNext.event);\n      }\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n      if (componentWillReceiveProps) return componentWillReceiveProps.call.apply(componentWillReceiveProps, [this, nextProps].concat(args));\n    };\n  }\n  return descriptor;\n}\nexport default methodWrapperScoped;","map":{"version":3,"names":["matchKeys","parseKeys","methodWrapperScoped","_ref","target","descriptor","keys","componentWillReceiveProps","fn","value","console","warn","_shouldTrigger","keydownThis","keydownNext","event","keySets","some","keySet","nextProps","keydown","props","call","_len","arguments","length","args","Array","_key","apply","concat"],"sources":["/Users/hackyourfuture/Desktop/searchbar/ui/node_modules/react-keydown/es/decorators/method_decorator_scoped.js"],"sourcesContent":["/**\n * @module methodWrapperScoped\n *\n */\nimport matchKeys from '../lib/match_keys';\nimport parseKeys from '../lib/parse_keys';\n\n/**\n * methodWrapperScoped\n *\n * @access public\n * @param {object} args All args necessary for decorating the method\n * @param {object} args.target The decorated method's class object\n * @param {object} args.descriptor The method's descriptor object\n * @param {array} args.keys The key codes bound to the decorated method\n * @return {object} The method's descriptor object\n */\nfunction methodWrapperScoped(_ref) {\n  var target = _ref.target,\n      descriptor = _ref.descriptor,\n      keys = _ref.keys;\n  var componentWillReceiveProps = target.componentWillReceiveProps;\n\n  var fn = descriptor.value;\n  if (!keys) {\n    console.warn(fn + ': keydownScoped requires one or more keys');\n  } else {\n\n    /**\n     * _shouldTrigger\n     *\n     * @access private\n     * @param {object} thisProps Exsting props from the wrapped component\n     * @param {object} thisProps.keydown The namespaced state from the higher-order\n     * component (class_decorator)\n     * @param {object} nextProps The incoming props from the wrapped component\n     * @param {object} nextProps.keydown The namescaped state from the higher-order\n     * component (class_decorator)\n     * @param {array} keys The keys bound to the decorated method\n     * @return {boolean} Whether all tests have passed\n     */\n    var _shouldTrigger = function _shouldTrigger(keydownThis, keydownNext) {\n      if (!(keydownNext && keydownNext.event && !keydownThis.event)) return false;\n\n      return keySets.some(function (keySet) {\n        return matchKeys({ keySet: keySet, event: keydownNext.event });\n      });\n    };\n\n    // wrap the component's lifecycle method to intercept key codes coming down\n    // from the wrapped/scoped component up the view hierarchy. if new keydown\n    // event has arrived and the key codes match what was specified in the\n    // decorator, call the wrapped method.\n\n\n    var keySets = parseKeys(keys);target.componentWillReceiveProps = function (nextProps) {\n      var keydownNext = nextProps.keydown;\n      var keydownThis = this.props.keydown;\n\n\n      if (_shouldTrigger(keydownThis, keydownNext)) {\n        return fn.call(this, keydownNext.event);\n      }\n\n      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        args[_key - 1] = arguments[_key];\n      }\n\n      if (componentWillReceiveProps) return componentWillReceiveProps.call.apply(componentWillReceiveProps, [this, nextProps].concat(args));\n    };\n  }\n\n  return descriptor;\n}\n\nexport default methodWrapperScoped;"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAOA,SAAS,MAAM,mBAAmB;AACzC,OAAOC,SAAS,MAAM,mBAAmB;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,mBAAmBA,CAACC,IAAI,EAAE;EACjC,IAAIC,MAAM,GAAGD,IAAI,CAACC,MAAM;IACpBC,UAAU,GAAGF,IAAI,CAACE,UAAU;IAC5BC,IAAI,GAAGH,IAAI,CAACG,IAAI;EACpB,IAAIC,yBAAyB,GAAGH,MAAM,CAACG,yBAAyB;EAEhE,IAAIC,EAAE,GAAGH,UAAU,CAACI,KAAK;EACzB,IAAI,CAACH,IAAI,EAAE;IACTI,OAAO,CAACC,IAAI,CAACH,EAAE,GAAG,2CAA2C,CAAC;EAChE,CAAC,MAAM;IAEL;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;IACI,IAAII,cAAc,GAAG,SAASA,cAAcA,CAACC,WAAW,EAAEC,WAAW,EAAE;MACrE,IAAI,EAAEA,WAAW,IAAIA,WAAW,CAACC,KAAK,IAAI,CAACF,WAAW,CAACE,KAAK,CAAC,EAAE,OAAO,KAAK;MAE3E,OAAOC,OAAO,CAACC,IAAI,CAAC,UAAUC,MAAM,EAAE;QACpC,OAAOlB,SAAS,CAAC;UAAEkB,MAAM,EAAEA,MAAM;UAAEH,KAAK,EAAED,WAAW,CAACC;QAAM,CAAC,CAAC;MAChE,CAAC,CAAC;IACJ,CAAC;;IAED;IACA;IACA;IACA;;IAGA,IAAIC,OAAO,GAAGf,SAAS,CAACK,IAAI,CAAC;IAACF,MAAM,CAACG,yBAAyB,GAAG,UAAUY,SAAS,EAAE;MACpF,IAAIL,WAAW,GAAGK,SAAS,CAACC,OAAO;MACnC,IAAIP,WAAW,GAAG,IAAI,CAACQ,KAAK,CAACD,OAAO;MAGpC,IAAIR,cAAc,CAACC,WAAW,EAAEC,WAAW,CAAC,EAAE;QAC5C,OAAON,EAAE,CAACc,IAAI,CAAC,IAAI,EAAER,WAAW,CAACC,KAAK,CAAC;MACzC;MAEA,KAAK,IAAIQ,IAAI,GAAGC,SAAS,CAACC,MAAM,EAAEC,IAAI,GAAGC,KAAK,CAACJ,IAAI,GAAG,CAAC,GAAGA,IAAI,GAAG,CAAC,GAAG,CAAC,CAAC,EAAEK,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGL,IAAI,EAAEK,IAAI,EAAE,EAAE;QACtGF,IAAI,CAACE,IAAI,GAAG,CAAC,CAAC,GAAGJ,SAAS,CAACI,IAAI,CAAC;MAClC;MAEA,IAAIrB,yBAAyB,EAAE,OAAOA,yBAAyB,CAACe,IAAI,CAACO,KAAK,CAACtB,yBAAyB,EAAE,CAAC,IAAI,EAAEY,SAAS,CAAC,CAACW,MAAM,CAACJ,IAAI,CAAC,CAAC;IACvI,CAAC;EACH;EAEA,OAAOrB,UAAU;AACnB;AAEA,eAAeH,mBAAmB"},"metadata":{},"sourceType":"module","externalDependencies":[]}