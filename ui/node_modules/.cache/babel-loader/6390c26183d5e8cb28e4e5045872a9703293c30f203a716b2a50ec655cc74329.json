{"ast":null,"code":"var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\n\n/**\n * @module methodWrapper\n *\n */\nimport * as store from '../store';\nimport { onMount, onUnmount, _onKeyDown } from '../event_handlers';\n\n/**\n * _isReactKeyDown\n *\n * @access private\n * @param {object} event The possibly synthetic event passed as an argument with\n * the method invocation.\n * @return {boolean}\n */\nfunction _isReactKeyDown(event) {\n  return event && (typeof event === 'undefined' ? 'undefined' : _typeof(event)) === 'object' && event.nativeEvent instanceof window.KeyboardEvent && event.type === 'keydown';\n}\n\n/**\n * methodWrapper\n *\n * @access public\n * @param {object} args All arguments necessary for wrapping method\n * @param {object} args.target The decorated class\n * @param {object} args.descriptor Method descriptor\n * @param {array} args.keys The array of keys bound to the given method\n * @return {object} The method descriptor\n */\nfunction methodWrapper(_ref) {\n  var target = _ref.target,\n    descriptor = _ref.descriptor,\n    keys = _ref.keys;\n  var fn = descriptor.value;\n\n  // if we haven't already created a binding for this class (via another\n  // decorated method), wrap these lifecycle methods.\n  if (!store.getBinding(target)) {\n    var componentDidMount = target.componentDidMount,\n      componentWillUnmount = target.componentWillUnmount;\n    target.componentDidMount = function () {\n      onMount(this);\n      if (componentDidMount) return componentDidMount.call(this);\n    };\n    target.componentWillUnmount = function () {\n      onUnmount(this);\n      if (componentWillUnmount) return componentWillUnmount.call(this);\n    };\n  }\n\n  // add this binding of keys and method to the target's bindings\n  store.setBinding({\n    keys: keys,\n    target: target,\n    fn: fn\n  });\n  descriptor.value = function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    var maybeEvent = args[0];\n    if (_isReactKeyDown(maybeEvent)) {\n      // proxy method in order to use @keydown as filter for keydown events coming\n      // from an actual onKeyDown binding (as identified by react's addition of\n      // 'nativeEvent' + type === 'keydown')\n      if (!maybeEvent.ctrlKey) {\n        // we already whitelist shortcuts with ctrl modifiers so if we were to\n        // fire it again here the method would trigger twice. see https://github.com/glortho/react-keydown/issues/38\n        return _onKeyDown(maybeEvent, true);\n      }\n    } else if (!maybeEvent || !(maybeEvent instanceof window.KeyboardEvent) || maybeEvent.type !== 'keydown') {\n      // if our first argument is a keydown event it is being handled by our\n      // binding system. if it's anything else, just pass through.\n      return fn.call.apply(fn, [this].concat(args));\n    }\n  };\n  return descriptor;\n}\nexport default methodWrapper;","map":{"version":3,"names":["_typeof","Symbol","iterator","obj","constructor","prototype","store","onMount","onUnmount","_onKeyDown","_isReactKeyDown","event","nativeEvent","window","KeyboardEvent","type","methodWrapper","_ref","target","descriptor","keys","fn","value","getBinding","componentDidMount","componentWillUnmount","call","setBinding","_len","arguments","length","args","Array","_key","maybeEvent","ctrlKey","apply","concat"],"sources":["/Users/hackyourfuture/Desktop/searchbar/ui/node_modules/react-keydown/es/decorators/method_decorator.js"],"sourcesContent":["var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\n * @module methodWrapper\n *\n */\nimport * as store from '../store';\nimport { onMount, onUnmount, _onKeyDown } from '../event_handlers';\n\n/**\n * _isReactKeyDown\n *\n * @access private\n * @param {object} event The possibly synthetic event passed as an argument with\n * the method invocation.\n * @return {boolean}\n */\nfunction _isReactKeyDown(event) {\n  return event && (typeof event === 'undefined' ? 'undefined' : _typeof(event)) === 'object' && event.nativeEvent instanceof window.KeyboardEvent && event.type === 'keydown';\n}\n\n/**\n * methodWrapper\n *\n * @access public\n * @param {object} args All arguments necessary for wrapping method\n * @param {object} args.target The decorated class\n * @param {object} args.descriptor Method descriptor\n * @param {array} args.keys The array of keys bound to the given method\n * @return {object} The method descriptor\n */\nfunction methodWrapper(_ref) {\n  var target = _ref.target,\n      descriptor = _ref.descriptor,\n      keys = _ref.keys;\n\n\n  var fn = descriptor.value;\n\n  // if we haven't already created a binding for this class (via another\n  // decorated method), wrap these lifecycle methods.\n  if (!store.getBinding(target)) {\n    var componentDidMount = target.componentDidMount,\n        componentWillUnmount = target.componentWillUnmount;\n\n\n    target.componentDidMount = function () {\n      onMount(this);\n      if (componentDidMount) return componentDidMount.call(this);\n    };\n\n    target.componentWillUnmount = function () {\n      onUnmount(this);\n      if (componentWillUnmount) return componentWillUnmount.call(this);\n    };\n  }\n\n  // add this binding of keys and method to the target's bindings\n  store.setBinding({ keys: keys, target: target, fn: fn });\n\n  descriptor.value = function () {\n    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var maybeEvent = args[0];\n\n    if (_isReactKeyDown(maybeEvent)) {\n      // proxy method in order to use @keydown as filter for keydown events coming\n      // from an actual onKeyDown binding (as identified by react's addition of\n      // 'nativeEvent' + type === 'keydown')\n      if (!maybeEvent.ctrlKey) {\n        // we already whitelist shortcuts with ctrl modifiers so if we were to\n        // fire it again here the method would trigger twice. see https://github.com/glortho/react-keydown/issues/38\n        return _onKeyDown(maybeEvent, true);\n      }\n    } else if (!maybeEvent || !(maybeEvent instanceof window.KeyboardEvent) || maybeEvent.type !== 'keydown') {\n      // if our first argument is a keydown event it is being handled by our\n      // binding system. if it's anything else, just pass through.\n      return fn.call.apply(fn, [this].concat(args));\n    }\n  };\n\n  return descriptor;\n}\n\nexport default methodWrapper;"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}