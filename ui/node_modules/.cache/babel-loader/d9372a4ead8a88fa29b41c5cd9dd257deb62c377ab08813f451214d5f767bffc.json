{"ast":null,"code":"/**\n * @module domHelpers\n *\n */\nimport ReactDOM from 'react-dom';\nvar focusableSelector = 'a[href], button, input, object, select, textarea, [tabindex]';\n\n/**\n * bindFocusables: Find any focusable child elements of the component instance and\n * add an onFocus handler to focus our keydown handlers on the parent component\n * when user keys applies focus to the element.\n *\n * NOTE: One limitation of this right now is that if you tab out of the\n * component, _focusedInstance will still be set until next click or mount or\n * controlled focus.\n *\n * @access public\n * @param {object} instance The key-bound component instance\n * @param {callback} activateOnFocus The fn to fire when element is focused\n */\nfunction bindFocusables(instance, activateOnFocus) {\n  if (document.querySelectorAll) {\n    try {\n      var node = ReactDOM.findDOMNode(instance);\n      if (node) {\n        var focusables = node.querySelectorAll(focusableSelector);\n        if (focusables.length) {\n          var onFocus = function onFocus(element) {\n            var onFocusPrev = element.onfocus;\n            return function (event) {\n              activateOnFocus(instance);\n              if (onFocusPrev) onFocusPrev.call(element, event);\n            };\n          };\n          Array.prototype.slice.call(focusables).forEach(function (element) {\n            return element.onfocus = onFocus(element);\n          });\n        }\n      }\n    } catch (error) {\n      // noop, mostly suppressing error here https://github.com/glortho/react-keydown/issues/76\n    }\n  }\n}\n\n/**\n * findContainerNodes: Called by our click handler to find instances with nodes\n * that are equal to or that contain the click target. Any that pass this test\n * will be recipients of the next keydown event.\n *\n * @access public\n * @param {object} target The click event.target DOM element\n * @return {function} Reducer function\n */\nfunction findContainerNodes(target) {\n  return function (memo, instance) {\n    try {\n      var node = ReactDOM.findDOMNode(instance);\n      if (node && (node === target || node.contains(target))) {\n        memo.push({\n          instance: instance,\n          node: node\n        });\n      }\n    } finally {\n      return memo;\n    }\n  };\n}\n\n/**\n * sortByDOMPosition: Called by our click handler to sort a list of instances\n * according to least -> most nested. This is so that if multiple keybound\n * instances have nodes that are ancestors of the click target, they will be\n * sorted to let the instance closest to the click target get first dibs on the\n * next key down event.\n */\nfunction sortByDOMPosition(a, b) {\n  return a.node.compareDocumentPosition(b.node) === 10 ? 1 : -1;\n}\nexport default {\n  bindFocusables: bindFocusables,\n  findContainerNodes: findContainerNodes,\n  sortByDOMPosition: sortByDOMPosition\n};","map":{"version":3,"names":["ReactDOM","focusableSelector","bindFocusables","instance","activateOnFocus","document","querySelectorAll","node","findDOMNode","focusables","length","onFocus","element","onFocusPrev","onfocus","event","call","Array","prototype","slice","forEach","error","findContainerNodes","target","memo","contains","push","sortByDOMPosition","a","b","compareDocumentPosition"],"sources":["/Users/hackyourfuture/Desktop/searchbar/ui/node_modules/react-keydown/es/lib/dom_helpers.js"],"sourcesContent":["/**\n * @module domHelpers\n *\n */\nimport ReactDOM from 'react-dom';\n\nvar focusableSelector = 'a[href], button, input, object, select, textarea, [tabindex]';\n\n/**\n * bindFocusables: Find any focusable child elements of the component instance and\n * add an onFocus handler to focus our keydown handlers on the parent component\n * when user keys applies focus to the element.\n *\n * NOTE: One limitation of this right now is that if you tab out of the\n * component, _focusedInstance will still be set until next click or mount or\n * controlled focus.\n *\n * @access public\n * @param {object} instance The key-bound component instance\n * @param {callback} activateOnFocus The fn to fire when element is focused\n */\nfunction bindFocusables(instance, activateOnFocus) {\n  if (document.querySelectorAll) {\n    try {\n      var node = ReactDOM.findDOMNode(instance);\n      if (node) {\n        var focusables = node.querySelectorAll(focusableSelector);\n        if (focusables.length) {\n          var onFocus = function onFocus(element) {\n            var onFocusPrev = element.onfocus;\n            return function (event) {\n              activateOnFocus(instance);\n              if (onFocusPrev) onFocusPrev.call(element, event);\n            };\n          };\n          Array.prototype.slice.call(focusables).forEach(function (element) {\n            return element.onfocus = onFocus(element);\n          });\n        }\n      }\n    } catch (error) {\n      // noop, mostly suppressing error here https://github.com/glortho/react-keydown/issues/76\n    }\n  }\n}\n\n/**\n * findContainerNodes: Called by our click handler to find instances with nodes\n * that are equal to or that contain the click target. Any that pass this test\n * will be recipients of the next keydown event.\n *\n * @access public\n * @param {object} target The click event.target DOM element\n * @return {function} Reducer function\n */\nfunction findContainerNodes(target) {\n  return function (memo, instance) {\n    try {\n      var node = ReactDOM.findDOMNode(instance);\n      if (node && (node === target || node.contains(target))) {\n        memo.push({ instance: instance, node: node });\n      }\n    } finally {\n      return memo;\n    }\n  };\n}\n\n/**\n * sortByDOMPosition: Called by our click handler to sort a list of instances\n * according to least -> most nested. This is so that if multiple keybound\n * instances have nodes that are ancestors of the click target, they will be\n * sorted to let the instance closest to the click target get first dibs on the\n * next key down event.\n */\nfunction sortByDOMPosition(a, b) {\n  return a.node.compareDocumentPosition(b.node) === 10 ? 1 : -1;\n}\n\nexport default { bindFocusables: bindFocusables, findContainerNodes: findContainerNodes, sortByDOMPosition: sortByDOMPosition };"],"mappings":"AAAA;AACA;AACA;AACA;AACA,OAAOA,QAAQ,MAAM,WAAW;AAEhC,IAAIC,iBAAiB,GAAG,8DAA8D;;AAEtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,cAAcA,CAACC,QAAQ,EAAEC,eAAe,EAAE;EACjD,IAAIC,QAAQ,CAACC,gBAAgB,EAAE;IAC7B,IAAI;MACF,IAAIC,IAAI,GAAGP,QAAQ,CAACQ,WAAW,CAACL,QAAQ,CAAC;MACzC,IAAII,IAAI,EAAE;QACR,IAAIE,UAAU,GAAGF,IAAI,CAACD,gBAAgB,CAACL,iBAAiB,CAAC;QACzD,IAAIQ,UAAU,CAACC,MAAM,EAAE;UACrB,IAAIC,OAAO,GAAG,SAASA,OAAOA,CAACC,OAAO,EAAE;YACtC,IAAIC,WAAW,GAAGD,OAAO,CAACE,OAAO;YACjC,OAAO,UAAUC,KAAK,EAAE;cACtBX,eAAe,CAACD,QAAQ,CAAC;cACzB,IAAIU,WAAW,EAAEA,WAAW,CAACG,IAAI,CAACJ,OAAO,EAAEG,KAAK,CAAC;YACnD,CAAC;UACH,CAAC;UACDE,KAAK,CAACC,SAAS,CAACC,KAAK,CAACH,IAAI,CAACP,UAAU,CAAC,CAACW,OAAO,CAAC,UAAUR,OAAO,EAAE;YAChE,OAAOA,OAAO,CAACE,OAAO,GAAGH,OAAO,CAACC,OAAO,CAAC;UAC3C,CAAC,CAAC;QACJ;MACF;IACF,CAAC,CAAC,OAAOS,KAAK,EAAE;MACd;IAAA;EAEJ;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASC,kBAAkBA,CAACC,MAAM,EAAE;EAClC,OAAO,UAAUC,IAAI,EAAErB,QAAQ,EAAE;IAC/B,IAAI;MACF,IAAII,IAAI,GAAGP,QAAQ,CAACQ,WAAW,CAACL,QAAQ,CAAC;MACzC,IAAII,IAAI,KAAKA,IAAI,KAAKgB,MAAM,IAAIhB,IAAI,CAACkB,QAAQ,CAACF,MAAM,CAAC,CAAC,EAAE;QACtDC,IAAI,CAACE,IAAI,CAAC;UAAEvB,QAAQ,EAAEA,QAAQ;UAAEI,IAAI,EAAEA;QAAK,CAAC,CAAC;MAC/C;IACF,CAAC,SAAS;MACR,OAAOiB,IAAI;IACb;EACF,CAAC;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASG,iBAAiBA,CAACC,CAAC,EAAEC,CAAC,EAAE;EAC/B,OAAOD,CAAC,CAACrB,IAAI,CAACuB,uBAAuB,CAACD,CAAC,CAACtB,IAAI,CAAC,KAAK,EAAE,GAAG,CAAC,GAAG,CAAC,CAAC;AAC/D;AAEA,eAAe;EAAEL,cAAc,EAAEA,cAAc;EAAEoB,kBAAkB,EAAEA,kBAAkB;EAAEK,iBAAiB,EAAEA;AAAkB,CAAC"},"metadata":{},"sourceType":"module","externalDependencies":[]}